#include "recognizer.h"
#include "Common.h"
#include <samples/slog.hpp>
#include <inference_engine.hpp>
#include <iostream>
#include <stdio.h>
#include <gflags/gflags.h>
#include <samples/common.hpp> //#include <samples/ocv_common.hpp>
#include <ext_list.hpp>
#include <chrono>
#define ONE_LINE_LPR_CLASS_ID 6
#define TWO_LINE_LPR_CLASS_ID 5
#define PROVINCE "<GuiLin>"
Recognizer::Recognizer(const std::string& inputXml, const std::string& inputBin, const std::string& inputDevice,
                       const float thresh, const float iou, const int nireq):input_xml(inputXml), thresh(thresh), iou(iou), nireq(nireq){
        try {
            // --------------------------- 1. Load Plugin for inference engine -------------------------------------
            slog::info << "Loading plugin" << slog::endl;
            InferencePlugin plugin = PluginDispatcher({"../../../lib/intel64", ""}).getPluginByDevice(inputDevice);
            //printPluginVersion(plugin, std::cout);

            /**Loading extensions to the plugin **/

            /** Loading default extensions **/
            if (inputDevice.find("CPU") != std::string::npos) {
                /**
                 * cpu_extensions library is compiled from the "extension" folder containing
                 * custom CPU layer implementations.
                **/
                plugin.AddExtension(std::make_shared<Extensions::Cpu::CpuExtensions>());
            }
            // -----------------------------------------------------------------------------------------------------

            // --------------- 2. Reading the IR generated by the Model Optimizer (.xml and .bin files) ------------
            slog::info << "Loading network files" << slog::endl;
            //CNNNetReader netReader;
            /** Reading network model **/
            netReader.ReadNetwork(inputXml);
            /** Setting batch size to 1 **/
            slog::info << "Batch size is forced to  1." << slog::endl;
            netReader.getNetwork().setBatchSize(1);
            /** Extracting the model name and loading its weights **/
            std::string binFileName = fileNameNoExt(inputXml) + ".bin";
            netReader.ReadWeights(binFileName);
            /** Reading labels (if specified) **/
            std::string labelFileName = fileNameNoExt(inputXml) + ".labels";
            std::ifstream inputFile(labelFileName);
            std::copy(std::istream_iterator<std::string>(inputFile),
                      std::istream_iterator<std::string>(),
                      std::back_inserter(labels));
            // -----------------------------------------------------------------------------------------------------

            // --------------------------- 3. Configuring input and output -----------------------------------------
            // --------------------------------- Preparing input blobs ---------------------------------------------
            /** LPR network should have 2 inputs (and second is just a stub) and one output **/
            // ---------------------------Check inputs ------------------------------------------------------
            slog::info << "Checking LPR Network inputs" << slog::endl;
            inputInfo = InputsDataMap (netReader.getNetwork().getInputsInfo());
            if (inputInfo.size() != 2) {
                throw std::logic_error("LPR should have 2 inputs");
            }
            InputInfo::Ptr& inputInfoFirst = inputInfo.begin()->second;
            inputInfoFirst->setInputPrecision(Precision::U8);
            if (/*FLAGS_auto_resize*/false) {
                inputInfoFirst->getPreProcess().setResizeAlgorithm(ResizeAlgorithm::RESIZE_BILINEAR);
                inputInfoFirst->getInputData()->setLayout(Layout::NHWC);
            } else {
                inputInfoFirst->getInputData()->setLayout(Layout::NCHW);
            }
            //auto inputName = inputInfo.begin()->first;
            auto sequenceInput = (++inputInfo.begin());
            //auto inputSeqName = sequenceInput->first;
            if (sequenceInput->second->getTensorDesc().getDims()[0] != maxSequenceSizePerPlate) {
                throw std::logic_error("LPR post-processing assumes certain maximum sequences");
            }
            // -----------------------------------------------------------------------------------------------------


            // --------------------------------- Preparing output blobs -------------------------------------------
            slog::info << "Checking that the outputs are as the demo expects" << slog::endl;
            outputInfo = OutputsDataMap(netReader.getNetwork().getOutputsInfo());
            outputName = outputInfo.begin()->first;
            if (outputInfo.size() != 1) {
                throw std::logic_error("This net only accepts networks with one layers");
            }
            for (auto &output : outputInfo) {
                output.second->setPrecision(Precision::FP32);
                output.second->setLayout(Layout::NCHW);
            }
            // -----------------------------------------------------------------------------------------------------

            // --------------------------- 4. Loading model to the plugin ------------------------------------------
            slog::info << "Loading recogzizer model to the plugin" << slog::endl;
            ExecutableNetwork network = plugin.LoadNetwork(netReader.getNetwork(), {});

            // -----------------------------------------------------------------------------------------------------

            // --------------------------- 5. Creating infer request -----------------------------------------------
            for(int i=0; i<this->nireq; i++){
                this->IfReqs[i] = network.CreateInferRequestPtr();
            }
            //async_infer_request_next = network.CreateInferRequestPtr();
            //async_infer_request_curr = network.CreateInferRequestPtr();
            // -----------------------------------------------------------------------------------------------------
        }
        catch (const std::exception& error) {
            std::cerr << "[ ERROR ] " << error.what() << std::endl;
        }
        catch (...) {
            std::cerr << "[ ERROR ] Unknown/internal exception happened." << std::endl;
        }

}

std::string Recognizer::GetLicencePlateText(InferRequest::Ptr request) {
    static std::vector<std::string> items = {
            "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
            "<Anhui>", "<Beijing>", "<Chongqing>", "<Fujian>",
            "<Gansu>", "<Guangdong>", "<Guangxi>", "<Guizhou>",
            "<Hainan>", "<Hebei>", "<Heilongjiang>", "<Henan>",
            "<HongKong>", "<Hubei>", "<Hunan>", "<InnerMongolia>",
            "<Jiangsu>", "<Jiangxi>", "<Jilin>", "<Liaoning>",
            "<Macau>", "<Ningxia>", "<Qinghai>", "<Shaanxi>",
            "<Shandong>", "<Shanghai>", "<Shanxi>", "<Sichuan>",
            "<Tianjin>", "<Tibet>", "<Xinjiang>", "<Yunnan>",
            "<Zhejiang>", "<police>",
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
            "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
            "U", "V", "W", "X", "Y", "Z"
    };
    // up to 88 items per license plate, ended with "-1"
    const auto data = request->GetBlob(outputName)->buffer().as<float*>();
    std::string result;
    for (int i = 0; i < maxSequenceSizePerPlate; i++) {
        if (data[i] == -1)
            break;
        result += items[data[i]];
    }

    return result;
}

void Recognizer::fillSeqBlob(InferRequest::Ptr inferRequest) {
    auto sequenceInput = (++inputInfo.begin());
    auto inputSeqName = sequenceInput->first;
    Blob::Ptr seqBlob = inferRequest->GetBlob(inputSeqName);
    int maxSequenceSizePerPlate = seqBlob->getTensorDesc().getDims()[0];
    // second input is sequence, which is some relic from the training
    // it should have the leading 0.0f and rest 1.0f
    float* blob_data = seqBlob->buffer().as<float*>();
    blob_data[0] = 0.0f;
    std::fill(blob_data + 1, blob_data + maxSequenceSizePerPlate, 1.0f);
}

bool Recognizer::FindClassObjects(std::vector<DetectionObject>& objects,
                                  std::vector<int>& target_idxes,
                                  const int target_class_id){
    bool bRet = false;
    size_t len = objects.size();
    for(size_t i=0; i<len; i++){
        if((objects[i].class_id == target_class_id) && (objects[i].confidence > this->thresh)){
            target_idxes.push_back(i);
            bRet = true;
        }
    }
    return bRet;
}

bool Recognizer::CropObjectRegion(DetectionObject& object, cv::Mat frame, cv::Mat& object_region){
    cv::Rect roi ;
    int width = object.xmax - object.xmin;
    int height = object.ymax - object.ymin;
    int expand_w = width * 0.1;
    int expand_h = height * 0.2;
    roi.x = std::max(0, object.xmin - expand_w);
    roi.y = std::max(0, object.ymin - expand_h);
    roi.width = std::min(object.xmax - object.xmin + 2*expand_w, frame.cols - roi.x);
    roi.height = std::min(object.ymax - object.ymin + 2*expand_h, frame.rows - roi.y);
    //slog::info << "roi.x:" << roi.x << " roi.y:" << roi.y << " roi.width:" << roi.width << " roi.height:"<< roi.height << slog::endl;
    object_region = frame(roi);
    return true;
}

bool Recognizer::GetTargetFrames(cv::Mat frame, std::vector<DetectionObject>& objects, std::vector<int>& plate_idxes, std::vector<cv::Mat>& plate_frames){
    bool bRet = false;
    for(int i=0; i<plate_idxes.size(); i++){
        cv::Mat region;
        this->CropObjectRegion(objects[plate_idxes[i]], frame, region);
        plate_frames.push_back(region);
        bRet=true;
    }
    return bRet;
}

void Recognizer::FakeProvinceFeild(std::string& lpr_txt){
    int iPos1 = lpr_txt.find('<');
    int iPos2 = lpr_txt.find('>');
    //std::string str_target = lpr_txt.substr(iPos1, iPos2-iPos1 + 1);
    if((iPos1 != lpr_txt.npos) && (iPos2 != lpr_txt.npos)){
        lpr_txt.replace(iPos1, iPos2-iPos1+1, PROVINCE);
    }
    else{
        lpr_txt.insert(0, PROVINCE);
    }
    //lpr_txt.replace(lpr_txt.find("<police>"), strlen("<police>"), "");
}

int Recognizer::Recognize(int idx, const cv::Mat coresponding_frame, std::vector<DetectionObject>& objects){
    std::vector<int> plate_idxes;
    //slog::info << "into lpr recognize " << slog::endl;
    //int class_plate_id = 6;
    std::vector<cv::Mat> plate_frames;
    if(this->FindClassObjects(objects, plate_idxes, ONE_LINE_LPR_CLASS_ID)){
        this->GetTargetFrames(coresponding_frame, objects, plate_idxes, plate_frames);
        try {
            for(int i=0; i<plate_frames.size(); i++){
                //slog::info << "Start lpr inference " << slog::endl;
                cv::Mat frame = plate_frames[i];
                /*cv::Mat temp;
                ChangeMotorLPR2VeichleLPR(frame, temp);
                frame = temp;*/
                //cv::imwrite("one_line_lpr.jpg", frame);
                // --------------------------- 6. Doing inference ------------------------------------------------------
                slog::info << "Start lpr inference " << slog::endl;
                typedef std::chrono::duration<double, std::ratio<1, 1000>> ms;
                auto t0 = std::chrono::high_resolution_clock::now();
                auto inputName = inputInfo.begin()->first;
                //Main sync point:
                //slog::info << "current_request_id:" << idx << slog::endl;
                FrameToBlob(frame, IfReqs[idx], inputName);
                this->fillSeqBlob(IfReqs[idx]);
                IfReqs[idx]->StartAsync();
                if (OK == IfReqs[idx]->Wait(IInferRequest::WaitMode::RESULT_READY)){
                    std::string str_plate = GetLicencePlateText(IfReqs[idx]);
                    //FakeProvinceFeild(str_plate);
                    slog::info << "plate: " << str_plate << slog::endl;
                    //cv::imwrite("./lpr_result_dir/"+str_plate+".jpg", frame);
                    objects[plate_idxes[i]].set_text(str_plate);
                }
                auto t1 = std::chrono::high_resolution_clock::now();
                ms recognization = std::chrono::duration_cast<ms>(t1 - t0);
                slog::info << "recognization duration : " << recognization.count() << slog::endl;
            }

        }
        catch (const std::exception& error) {
            std::cerr << "[ ERROR ] " << error.what() << std::endl;
            return -100;
        }
        catch (...) {
            std::cerr << "[ ERROR ] Unknown/internal exception happened." << std::endl;
            return -100;
        }
        //slog::info << "Execution successful" << slog::endl;
    }

    return 0;
}
